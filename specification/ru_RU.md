# Спецификация `BDSF`[^1] 0.4
## `0.` Задачи
1. Файлы должны занимать как можно меньше места.
   > Любой файл данного формата должен занимать наименьшее кол-во места на диске. Предпочтительно, чтобы он занимал места меньше, чем `BSON`.
2. Файлы должны быть лёгкими для чтения и записи во всех смыслах (подразумевается программный код).
   > Программа, проводящая операции над файлом BDSF, **НЕ** должна слишком сильно нагружать систему.
3. У файла должны отсутствовать ограничения на размер.
   > Не смотря на задачу `0.1.`, данный формат не должен иметь никаких ограничений по размеру данных.
4. Должен подходить для нескольких целей.
   > Данный формат должен подходить как минимум для следующих целей: `Хранение данных` и `Передача данных по сети`.

## `1.` Запреты
1. Не используйте `Array[Byte]` вместо `Binary`
   > Если вы всё таки сделаете это, то при попадании в список нулевого байта чтение данного формата будет не верным.

## `2.` Хранение
### `2.1.` Основной формат
Структура файла выглядит данным образом:
```py
File {
    Byte        type      (1);
    Path[]      paths     (N);
    Document[]  documents (N);
}
```
> *Таблица `#1`*
> Название блока | Тип          | Длина (байты : биты) | Описание
> -------------- | ------------ | -------------------- | -------------------------------------------------------------------------------------
> `type`         | `Byte`       | `1 : 8`              | Тип файла, `0` - 1 документ; `1` - 2 документа.
> `paths`        | `Path[]`     | `N : B * 8`[^2]      | Список путей к документам (пишется без указания типа), иногда может не присутствовать
> `documents`    | `Document[]` | `N : B * 8`[^2]      | Список документов (пишется без указания типа)

Если первый байт это `0`, то будет использоватся прописанный выше формат. Если же он равен `1`, то будет использоваться данный формат:
```py
File {
    Byte      type     (1);
    Document  document (N);
}
```
> Используется таблица `#1`

### `2.2.` Начальные типы (`Path`, `Document`)
#### `2.2.1.` Path
> `DATA:<тип>` обозначает какой-либо тип из пункта `2.4.`
```py
Path {
    DATA:TV    key         (1 + N);
    DATA:TV[N] coordinates (1 + N);
}
```
> *Таблица `#2`*
> Название блока | Тип          | Длина (байты : биты)      | Описание
> -------------- | ------------ | ------------------------- | ---------------------------------------------------------------------------------------
> `key`          | `DATA:TV`    | `1 + N : 8 + (B * 8)`[^2] | Ключ любого типа из пункта `2.3.`, которое обозначает название документа
> `coordinates`  | `DATA:TV[N]` | `1 + N : 8 + (B * 8)`[^2] | Кол-во байт от начала файла, которое нужно прочитать, чтобы дойти до блока с документом

#### `2.2.2.` Document
> `DATA:<тип>` обозначает какой-либо тип из пункта `2.4.`
```py
Document {
    DATA:KTV data    (N);
    Byte     EOD = 0 (1);
```
> *Таблица `#3`*
> Название блока | Тип          | Длина (байты : биты) | Описание
> -------------- | ------------ | -------------------- | --------------------------------------
> `data`         | `BDSFT:KTV`  | `N : B * 8`[^2]      | Пары ключ-значение (`key-value`[^3])
> `EOD`          | `Byte`       | `1 : 8`              | Всегда `00`, сигнатура конца документа

### `2.3.` Типы данных
> `DATA:<тип>` обозначает какой-либо тип из пункта `2.4.`

*Таблица `#4`*
Тип                | Длина (байты : биты) | Диапозон                  | Байт-код | Формат
------------------ | -------------------- | ------------------------- | -------- | ----------------------------
`Byte`             | `1 : 8`              | `-128 - 127`              | `01`     | `-`
`Binary`           | `N : B * 8`[^2]      | `-`                       | `02`     | `2.3/1`
`UInt8`            | `1 : 8`              | `0 - 255`                 | `03`     | `HEX (big endian, unsigned)`
`Int16`            | `2 : 16`             | `-2¹⁵+1 - 2¹⁵-1`          | `04`     | `HEX (big endian, signed)`
`UInt16`           | `2 : 16`             | `0 - 2¹⁶-1`               | `05`     | `HEX (big endian, unsigned)`
`Int32`            | `4 : 32`             | `-2³¹+1 - 2³¹-1`          | `06`     | `HEX (big endian, signed)`
`UInt32`           | `4 : 32`             | `0 - 2³²-1`               | `07`     | `HEX (big endian, unsigned)`
`Int64`            | `8 : 64`             | `-2⁶³+1 - 2⁶³-1`          | `08`     | `HEX (big endian, signed)`
`UInt64`           | `8 : 64`             | `0 - 2⁶⁴-1`               | `09`     | `HEX (big endian, unsigned)`
`Int128`           | `16 : 128`           | `-2¹²⁷+1 - 2¹²⁷-1`        | `0A`     | `HEX (big endian, signed)`
`UInt128`          | `16 : 128`           | `0 - 2¹²⁸-1`              | `0B`     | `HEX (big endian, unsigned)`
`Float`            | `4 : 32`             | `~ 6 - 9 .` (`2.3/2`)     | `0C`     | `IEEE 754-2019`
`Double`           | `8 : 64`             | `~ 15 - 17 .` (`2.3/2`)   | `0D`     | `IEEE 754-2019`
`Decimal`          | `16 : 128`           | `28 - 29 .` (`2.3/2`)     | `0E`     | `IEEE 754-2019`
`Boolean`          | `1 : 8`              | `1 - 8`                   | `0F`     | `00 = false; 01 = true`
`String`           | `N : B * 8`[^2]      | `-`                       | `10`     | `C-String`
`Array`            | `N : B * 8`[^2]      | `-`                       | `11`     | `2.3/3`
`Dictionary`       | `N : B * 8`[^2]      | `-`                       | `12`     | `2.3/4`
`Timestamp`        | `4 : 32`             | `0 - 2147483647`          | `13`     | `Unix Timestamp`
`Timestamp64`      | `8 : 64`             | `0 - 9223372036854775807` | `14`     | `64-bit Timestamp`
`Array[Type]`      | `N : B * 8`[^2]      | `-`                       | `15`     | `2.3/5`
`Dictionary[Type]` | `N : B * 8`[^2]      | `-`                       | `16`     | `2.3/6`
`Null`             | `0 : 0`              | `0 - 0`                   | `17`     | `-`
`ItemID`           | `16 : 128`           | `Byte[16]`                | `18`     | `На данный момент не используется`
`PNG Image`        | `N : B * 8`[^2]      | `-`                       | `19`     | `2.3/7`

> #### Примечание `2.3/1`
> Данный тип состоит из двух частей:
> 1. Длина бинарной строки в формате `DATA:TV[N]`
> 2. Содержимое этой бинарной строки

> #### Примечание `2.3/2`
> `.` - Обозначает "чисел после точки"

> #### Примечание `2.3/3`
> Данный тип состоит из двух частей
> 1. Содержимое множества в формате `DATA:TV`
> 2. Сигнатура конца списка (всегда `00`)

> #### Примечание `2.3/4`
> Данный тип состоит из двух частей
> 1. Содержимое словаря в формате `DATA:KTV`
> 2. Сигнатура конца словаря (всегда `00`)

> #### Примечание `2.3/5`
> Данный тип состоит из трёх частей
> 1. 1 байт, который обозначает тип, которого будет всё содержимое списка
> 2. Содержимое множества в формате `DATA:V`
> 3. Сигнатура конца списка (всегда `00`)

> #### Примечание `2.3/6`
> Данный тип состоит из трёх частей
> 1. 1 байт, который обозначает тип, которого будет всё содержимое словаря
> 2. Содержимое словаря в формате `BDSFT:KV`
> 3. Сигнатура конца словаря (всегда `00`)

> #### Примечание `2.3/6`
> Данный тип это тот же самый PNG, но
> 1. В начале не должно быть PNG сигнатуры
> 2. В блоке `IHDR` отсутствуют поля: `Метод сжатия` и `Метод фильтрации`
> 3. Отсутствуют блок `IEND`

### `2.4.` Формат записи пар ключ-значение
> У всех документов используется следуящяя запись: KTV
> 
> Формат записи: `<chars>[\[<mtype>\]]`

**Значения:**
- `chars` - Символы, указывающие на блоки данных
- `mtype` - Основной тип

**Символы (`chars`):**
- `K` - Ключ, формата TV данного пукнта, N байт
- `T` - Тип значения, 1 байт
- `V` - Само значение, N байт

**Основные типы (`mtype`):**
- `N` - `Int16`, `Int32`, `Int64`, `Int128`, `UInt8`, `UInt16`, `UInt32`, `UInt64` и `UInt128`
- `F` - `Float`, `Double` и `Decimal128`

[^1]: BDSF *(**англ.** Binary Data Storage Format)* - Двоичный формат хранения данных.
[^2]: `N` = Любое число; `B` = Число байт.
[^3]: Тип `NoSQL` баз данных, при котором все данные хранятся ввиде ключа и его значения.
