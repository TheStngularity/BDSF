<p align=center><a href="en_US.md">English</a> • Русский</p>

# Спецификация `BDSFmt`[^1] 0.4
## `1.` Задачи
1. Файлы данного формата **НЕ** должны занимать много места
    > Для чего бы файл не использовался, он **НЕ** должен занимать места больше, чем требуется. Но это **НЕ** должно делаться в ущерб производительности.
2. Файлы данного формата **ДОЛЖНЫ** быть лёгкими и для чтения и для записи *(подразумевается программный код)*
    > Программа, которая выполняет операции над файлом **НЕ** должна сильно нагружать систему.
3. Не должно быть ограничений по размерам данных
    > Несмотря на задачу `#1`, у данных в `BDSFmt`[^1] не должно быть ограничений, если это не идёт в ущерб задачи `#2`.
4. Обратная совместимость
    > Формат должен быть обратно-совместимым. Например, если выйдет версия `0.5`, то она будет совместима с текущей версией.

## `2.` Хранения
### `2.1.` Структура файлов
Количество блоков в файле зависит от значения первого байта. Он же и является первым блоком. Он имеет тип `Byte` и может иметь два разных значения.

&nbsp;&nbsp;&nbsp;&nbsp;Если значение первого блока это `01` *(`1`)*, то следующий блок - это `paths`. Он является массивом типа `Path` *(пункт **2.2.** этой спецификации)*. Его можно назвать парой ключ-значение, где ключ это название документа (любого типа), а значение это количество байт от начала файла.

&nbsp;&nbsp;&nbsp;&nbsp;Последний блок - это `document (-s)`. В случае, если первый блок равен `01` *(`1`)*, то данный блок это массив типа `Document` *(пункт **2.3.** этой спецификации)*. Если же его значение это `00` *(`0`)*, то используется тип `Document`.

### `2.2.` Path
Как было сказано в пункте `2.1.`, данный тип состоит из двух блоков и его можно назвать парой ключ-значение. Первый блок это ключ. Он может иметь любой[^2] тип. Далее идёт блок `indent`. Он имеет тип `UInt`[^3] и обозначает отступ от начала файла до начала документа. Заканчивается этот блок на `00`.

### `2.3.` Document
Пожалуй, самый лёгкий глобальный тип данных. Он состоит из блока данных и сигнатуры конца. Начнём с блока данных. Это массив пар ключ-значение[^4]. Далее идёт сигнатура конца документа, она всегда имеет значение `00`.

## `3.` Типы данных
Данный формат имеет достаточно много типов данных.

### `3.1.` Бинарные типы
#### `3.1.1.` Byte
Как вы понимаете, тут всё просто. Значение представляет собой любой байт от `00` до `FF`. Его байт-код это `01`.

#### `3.1.2.` Binary
Тут немного посложнее. Данный тип состоит из двух частей. Первая часть это любое[^2] `UInt`[^3] число, оно обозначает длину далее идущих далее байтов. Вторая часть, как уже было сказано, это сами байты *(`Byte` тип)*. Байт-код этого типа это `02`.

### `3.2.` Числовые типы
#### `3.2.1.` UInt8
Это **8**и-битное число в `HEX (unsigned, big endian)` формате. Может иметь значения от `0` до `255`. Данный тип имеет `03` байт-код.

#### `3.2.2.` Int16
Это **16**и-битное число в `HEX (signed, big endian)` формате. Имеет значение от `-2¹⁵+1` до `2¹⁵-1`. Имеет `04` байт-код.

#### `3.2.3.` UInt16
Это **16**и-битное число в `HEX (unsigned, big endian)` формате. Может иметь значения от `0` до `2¹⁶-1`. Его байт-код `05`.

#### `3.2.4.` Int32
Это **32**х-битное число в `HEX (signed, big endian)` формате. Имеет значение от `-2³¹+1` до `2³¹-1`. Байт-код данного типа это `06`.

#### `3.2.5.` UInt32
Это **32**х-битное число в `HEX (unsigned, big endian)` формате. Может иметь значения от `0` до `2³²-1`. Его байт-код `07`.

#### `3.2.6.` Int64
Это **64**х-битное число в `HEX (signed, big endian)` формате. Имеет значение от `-2⁶³+1` до `2⁶³-1`. Байт-код данного типа это `08`.

#### `3.2.7.` UInt64
Это **64**х-битное число в `HEX (unsigned, big endian)` формате. Может иметь значения от `0` до `2⁶⁴-1`. Его байт-код `09`.

#### `3.2.8.` Int128
Это **128**и-битное число в `HEX (signed, big endian)` формате. Имеет значение от `-2¹²⁷+1` до `2¹²⁷-1`. Байт-код данного типа это `0A`.

#### `3.2.9` UInt128
Это **128**и-битное число в `HEX (unsigned, big endian)` формате. Имеет значение от `0` до `2¹²⁸-1`. Байт-код данного типа это `0B`.

#### `3.2.10` BigInt
Это число, которое может иметь любое кол-во бит. Сначала идёт кратное двум количество байт. Они обозначают само число в `HEX (signed, big endian)` формате. Заканчивается это тип на `00`. Он имеет `0C` байт-код.

#### `3.2.11` BigUInt
Это число, которое может иметь любое кол-во бит. Сначала идёт кратное двум количество байт. Они обозначают само число в `HEX (unsigned, big endian)` формате. Заканчивается это тип на `00`. Он имеет `0D` байт-код.

### `3.3.` Типы чисел с плавающей точкой
#### `3.3.1.` Float
Числа данного типа хранятся в [`IEEE 754-2019`](https://en.wikipedia.org/wiki/IEEE_754) формате. Занимает данный тип **32** бита и имеет `0E` байт-код.

#### `3.3.2.` Double
Числа данного типа хранятся в [`IEEE 754-2019`](https://en.wikipedia.org/wiki/IEEE_754) формате. Занимает данный тип **64** бита и имеет `0F` байт-код.

#### `3.3.3.` Decimal
Числа данного типа хранятся в [`IEEE 754-2019`](https://en.wikipedia.org/wiki/IEEE_754) формате. Занимает данный тип **128** бит и имеет `10` байт-код.

### `3.4.` Строковые типы
#### `3.4.1.` String
Представляет собой строку в `UTF-8` кодировке. Может занимать любое количество байт. В конце должен находится нулевой байт. Байт-код этого типа это `11`.

#### `3.4.2.` String16
**Устарело:** используйте `String`

#### `3.4.3.` String32
**Устарело:** используйте `String`

### `3.5.` Логический тип
Почти то же самое, что и `Byte`. Нулевое значение байта обозначает ложь, а значение `01` обозначает правду. Обозначается `14` байт-кодом.

### `3.6.` Массивы и словари
#### `3.6.1.` Array
Представляет собой массив, в котором может содержаться любой[^2], кроме `Array[Type]` и `Dictionary[KType, VType]` тип. После данных идёт нулевой байт, который обозначает конец массива. Имеет `15` байт-код.

#### `3.6.2.` Array[Type]
То же самое, что и `Array`, но после байта типа указывается байт-код того типа, который будет использоваться в данном массиве. При этом этот байт-код не должен иметь значение кода этого типа или `Dictionary[KType, VType]`. После этого идёт массив данных любого типа, но уже без указания кода типа. После всё также идёт нулевой байт. Обозначается `16` байт-кодом

#### `3.6.3.` Dicitonary
Представляет собой массив пар ключ-значение[^4]. Поделим эти пары на 2 части. Первая часть - это ключ. После идёт значение. Таких пар может быть сколько угодно. В конце идёт сигнатура конца (нулевой байт). Данный тип обозначается `17` байт-кодом.

#### `3.6.4.` Dictionary[KType, VType]
То же самое, что и `Dictionary`, но после байта типа указывается байт-код типа ключа и байт-код типа значения. После идёт всё то же самое, но уже без указания байт-кода типа у ключей и значений. После всё так же идёт нулевой байт. Обозначается `18` байт-кодом.

### `3.7.` Типы даты и времени
#### `3.7.1.` Timestamp
Это **32**х-битное число в формате `Unix Timestamp`. Тоесть число `Int32` типа, которое обозначает кол-во секунд с **1 января 1970 года *(по UTC)***. Байт-код данного типа - это `19`

#### `3.7.2.` Timestamp64
То же самое, что и `Timestamp`, но занимает **64** бита и является числом `Int64` типа. Зачем это нужно? Чтобы избежать [проблемы 2038 года](https://en.wikipedia.org/wiki/Year_2038_problem). Данный тип обозначается `1A` байт-кодом.

### `3.8.` Спец. Типы
#### `3.8.1.` Null
Тип, который можно использовать для неопределённых значений. У него нет никакого формата записи, указывается только байт-код данного типа. Тоесть `1B`.

#### `3.8.2.` ItemID
Тип, нужный для работы [SyrDB](https://github.com/TheStngularity/SyrDB). Представляет собой последовательность из **8** байт. Его можно назвать самым обычным `UUID`. Его байт-код - это `1C`.

[^1]: BDSFmt *(**англ.** **B**inary **D**ata **S**torage **F**or**m**a**t**)* - Двоичный формат хранения данных.
[^2]: При этом перед значением нужно указать байт-код типа.
[^3]: Любой тип из диапазона `UInt8` - `BigUInt`.
[^4]: И ключ и значение могут иметь любой[^2], кроме `Array[Type]` и `Dictionary[KType, VType]` тип. 