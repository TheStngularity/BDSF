# Спецификация `BDSF` 0.2
## 1. Принципы данного формата
1. Должен мало весить.
   > Данный формат должен занимать мало места на жёстком диске.
2. Он должен быть лёгким для чтения/записи через код.
   > Данный формат должно быть легко прочитать или записать через код, для этого идеально подходит двоичный вид файла.
3. При чтении/записи этого фомата ЦП и ОЗУ не должны нагружаться.
   > Его чтение/запись не должно быть сложной для системы задачей.

## 2. Формат хранения
### 2.1. Разделение на несколько "документов" в 1 файле
Чтобы не хранить "документы" в разных файлах данный формат предлагает следующюю запись:
```js
File {
    Byte[2]     Signature [2 байта];
    Path        Paths     [N байт];
    Document... Documents [N байт]
}
```

Блок        | Тип                   | Описание
----------- | --------------------- | ------------------------------------------------------------------------------------
`Signature` | **Byte[2]**           | `2` байта сигнатуры (`86 99`).                                                      
`Paths`     | **Path** (2.2.)       | `N` байт "путей" к документам. О них я расскажу в пункуте `2.2.`                    
`Documents` | **Document...** (2.3.)| `N` байт документов. Каждый документ это 1 объект, они будут описаны в пункте `2.3.`

### 2.2. Пути к документам
Все пути к документам имеют следующий формат:
```js
Path {
    ? Key         [1 + N байт];
    ? Coordinates [1 + N байт]
}
```

Блок          | Тип                          | Описание
------------- | ---------------------------- | --------------------------------------------------------------------------
`Key`         | **TV** (см. пункт 2.5.)      | Ключ документа, может быть любым типом, который был описан в `2.4.`       
`Coordinates` | **TV[N]** (см. пункт 2.5.) | Количество байт с начала файла до документа сохраненного по данному ключу.

### 2.3. Объекты документов
Как я уже говорил каждый документ это объект. Он имеет такой формат:
```js
Document {
    Byte[1] BOD = 0 [1 байт];
    ?       Data    [N байт];
    Byte[1] BOD = 0 [1 байт]
}
```

Блок   | Тип                      | Описание
------ | ------------------------ | ---------------------------------------------------
`BOD`  | **Byte[1]**              | Сигнатура начала и конца документа (Край документа)
`Data` | **KTV** (см. пункт 2.5.) | Данные (пары ключ-значения) документа

### 2.4. Типы данных
Тип             | Длина (Байты : Биты) | Диапозон                  | Байт кода типа | Формат
--------------- | :------------------: | ------------------------- | -------------- | ------
**Byte**        | 1 : 8                | `0 - 255`                 | `01`           | `-`
**Int16**       | 2 : 16               | `-2¹⁵+1 - 2¹⁵-1`          | `02`           | `Стандартный "big" HEX формат`
**Int32**       | 4 : 32               | `-2³¹+1 - 2³¹-1`          | `03`           | `Стандартный "big" HEX формат`
**Int64**       | 8 : 64               | `-2⁶³+1 - 2⁶³-1`          | `04`           | `Стандартный "big" HEX формат`
**Int128**      | 16 : 128             | `-2¹²⁷+1 - 2¹²⁷-1`        | `05`           | `Стандартный "big" HEX формат`
**UInt16**      | 2 : 16               | `0 - 2¹⁶-1`               | `06`           | `Стандартный "big" HEX формат`
**UInt32**      | 4 : 32               | `0 - 2³²-1`               | `07`           | `Стандартный "big" HEX формат`
**UInt64**      | 8 : 64               | `0 - 2⁶⁴-1`               | `08`           | `Стандартный "big" HEX формат`
**UInt128**     | 16 : 128             | `0 - 2¹²⁸-1`              | `09`           | `Стандартный "big" HEX формат`
**Float**       | 4 : 32               | `1 - 7 после .`           | `0A`           | `IEEE 754-2008`
**Double**      | 8 : 64               | `8 - 15 после .`          | `0B`           | `IEEE 754-2008`
**Decimal128**  | 16 : 128             | `16 - 23 после .`         | `0C`           | `IEEE 754-2008`
**Boolean**     | 1 : 8                | `0 - 1`                   | `0D`           | `0 = false; 1 = true`
**String**      | ? : ?                | `-`                       | `0E`           | `L{2 : Длина кодированной строки ~UInt16}`<br>`C{L : Строка в UTF-8}`
**List**        | ? : ?                | `-`                       | `0F`           | `B{1 : 1 край списка (00)}`<br>`C{L: Элементы, в формате TV (см. пункт 2.5.)}`<br>`B{1 : 2 край списка (00)}`
**Dictionary**  | ? : ?                | `-`                       | `10`           | `B{1 : 1 край списка (00)}`<br>`C{L: Элементы, в формате KTV (см. пункт 2.5.)}`<br>`B{1 : 2 край списка (00)}`
**Timestamp**   | 4 : 32               | `0 - 2147483647`          | `11`           | `Unix Timestamp`
**Timestamp64** | 8 : 64               | `0 - 9223372036854775807` | `12`           | `64-bit Timestamp`
**Binary**      | ? : ?                | `-`                       | `13`           | `L{2 : Количество байт ~UInt16}`<br>`C{L : Байты}`
**Null**        | 0 : 0                | `0 - 0`                   | `14`           | `-`
**ItemID**      | 16 : 128             | `UInt128`                 | `15`           | `См. data_storage/items/itemid в документации SyrDB для разработчиков`

### 2.5. Формат записи пар ключ-значение
Пары ключ значение имеют 1 формат.
> У документов используется следуящяя запись: **KTV**<br>
**Формат записи:** `<chars>[\[<mtype>\]]`<br>
**Значения:**
- `chars` - Символы, указывающие на блоки данных
- `mtype` - Основной тип

**Символы:**
- `K` - Ключ, формата **TV** данного пукнта, **N байт**
- `T` - Тип значения, **1 байт**
- `V` - Само значение, **N байт**

**Основные типы:**
- `N` - **Int16**, **Int32**, **Int64**, **Int128**, **UInt16**, **UInt32**, **UInt64** и **UInt128**
- `F` - **Float**, **Double** и **Decimal128**
