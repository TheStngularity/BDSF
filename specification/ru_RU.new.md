# Спецификация `BDSF`¹ 0.3
## `1.` Задачи
1. Файлы данного форматы должны занимать как можно меньше места.
   > Любой файл данного формата должен занимать как можно меньше места, желательно, чтобы он занимал места меньше, чем `BSON` и `JSON`.
2. Он должен быть лёгким для чтения и записи путём кода.
   > При чтении или записи программа, которая обрабатываем этот формат **НЕ** должна слишком сильно нагружать систему.
3. Не должно быть ограничений.
   > Не смотря на задачу `#1` из пункта `1.` у данного формата не должно быть никаких ограничений по размеру данных.
4. Должен подходит для нескольких целей.
   > Данный формат должен подходит для следующих целей: `Хранение данных (несколько документов)`, `Хранение данных (1 документ)` и `Передача данных по сети`.

## `2.` Хранение
### `2.1.` Основной формат
Из-за того, что в начала была поставлена задача о том, что формат должен подходит сразу для нескольких целей (`#4`, пункт `1.`) в начале указывается *(или не указывается)* 1 байт, который указывает на тип.
> Типа всего 3, тем временем как значений заданного байта предусмотрено 2. По этому у 3-о типа (`Передача данных по сети`) данного байта нет.

Если значение первого байта это `00` (0), то используется формат хранения данных в нескольких документах:
```py
File {
    Byte        type      (1);
    Path[]      paths     (N);
    Document[]  documents (N);
}
```
> *Таблица `#1`*
> Название блока | Тип          | Длина (байты : биты) | Описание
> -------------- | ------------ | -------------------- | -------------------------------------------------------
> `type`         | `Byte`       | `1 : 8`              | 1 байт, который указывает на то, какой тип используется
> `paths`        | `Path[]`     | `N : B * 8`²         | Список путей к документам (пишется без указания типа)
> `documents`    | `Document[]` | `N : B * 8`²         | Список документов (пишется без указания типа)

Если же значение первого байта будет `01` (1), то будет использоваться следующий формат:
```py
File {
    Byte     type     (1);
    Document document (N);
}
```
> Будет использоваться таблица `#1`

Если же данный байт отсутствует, то используется следующий формат:
```py
File {
    Document document (N);
}
```

### `2.2.` Начальные типы (`Path`, `Document`)
#### `2.2.1.` Path
> `BDSFT:<тип>` обозначает какой-либо тип из пункта `2.4.`
```py
Path {
    BDSFT:TV    key         (1 + N);
    BDSFT:TV[N] coordinates (1 + N);
}
```
> *Таблица `#2`*
> Название блока | Тип          | Длина (байты : биты)   | Описание
> -------------- | ------------ | ---------------------- | ---------------------------------------------------------------------------------------
> `key`          | `BDSFT:TV`   | `1 + N : 8 + (B * 8)`² | Ключ любого типа из пункта `2.3.`, которое обозначает название документа
> `paths`        | `Path[]`     | `1 + N : 8 + (B * 8)`² | Кол-во байт от начала файла, которое нужно прочитать, чтобы дойти до блока с документом

#### `2.2.2.` Document
> `BDSFT:<тип>` обозначает какой-либо тип из пункта `2.4.`
```py
Document {
    Byte      BOD = 0 (1);
    BDSFT:KTV data    (N);
    Byte      BOD = 0 (1);
```
> *Таблица `#3`*
> Название блока | Тип          | Длина (байты : биты) | Описание
> -------------- | ------------ | -------------------- | ---------------------------------------------------------------------------------------
> `BOD`          | `Byte`       | `1 : 8`              | Всегда `00`, сигнатура конца и края (боков) документа
> `data`         | `BDSFT:KTV`  | `N : B * 8`²         | Пары ключ-значение (`key-value`³)

### `2.3.` Типы данных
> `BDSFT:<тип>` обозначает какой-либо тип из пункта `2.4.`
> 
Тип                | Длина (байты : биты) | Диапозон                  | Байт-код | Формат
------------------ | -------------------- | ------------------------- | -------- | ----------------------------
`Byte`             | `1 : 8`              | `-128 - 127`              | `01`     | `-`
`UInt8`            | `1 : 8`              | `0 - 255`                 | `02`     | `-`
`Int16`            | `2 : 16`             | `-2¹⁵+1 - 2¹⁵-1`          | `03`     | `HEX (big endian, signed)`
`UInt16`           | `2 : 16`             | `0 - 2¹⁶-1`               | `04`     | `HEX (big endian, unsigned)`
`Int32`            | `4 : 32`             | `-2³¹+1 - 2³¹-1`          | `05`     | `HEX (big endian, signed)`
`UInt32`           | `4 : 32`             | `0 - 2³²-1`               | `06`     | `HEX (big endian, unsigned)`
`Int64`            | `8 : 64`             | `-2⁶³+1 - 2⁶³-1`          | `07`     | `HEX (big endian, signed)`
`UInt64`           | `8 : 64`             | `0 - 2⁶⁴-1`               | `08`     | `HEX (big endian, unsigned)`
`Int128`           | `16 : 128`           | `-2¹²⁷+1 - 2¹²⁷-1`        | `09`     | `HEX (big endian, signed)`
`UInt128`          | `16 : 128`           | `0 - 2¹²⁸-1`              | `0A`     | `HEX (big endian, unsigned)`
`Float`            | `4 : 32`             | `~ 6 - 9 .` (`2.3/1`)     | `0B`     | `IEEE 754-2019`
`Double`           | `8 : 64`             | `~ 15 - 17 .` (`2.3/1`)   | `0C`     | `IEEE 754-2019`
`Decimal`          | `16 : 128`           | `28 - 29 .` (`2.3/1`)     | `0D`     | `IEEE 754-2019`
`Boolean`          | `1 : 8`              | `1 - 8`                   | `0E`     | `00 = false; 01 = true`
`String`           | `N : B * 8`²         | `-`                       | `0F`     | `c-string`
`List`             | `N : B * 8`²         | `-`                       | `10`     | `2.3/2`
`Dictionary`       | `N : B * 8`²         | `-`                       | `11`     | `2.3/3`
`Timestamp`        | `4 : 32`             | `0 - 2147483647`          | `12`     | `Unix Timestamp`
`Timestamp64`      | `8 : 64`             | `0 - 9223372036854775807` | `13`     | `64-bit Timestamp`
`List[Type]`       | `N : B * 8`²         | `-`                       | `14`     | `2.3/4`
`Dictionary[Type]` | `N : B * 8`²         | `-`                       | `15`     | `2.3/5`
`Null`             | `0 : 0`              | `0 - 0`                   | `16`     | `-`
`ItemID`           | `16 : 128`           | `Byte[16]`                | `17`     | `На данный момент не используется`
`PNG Image`        | `N : B * 8`²         | `-`                       | `18`     | `2.3/6`

> **Примечание `2.3/1`**
> `.` - Обозначает "чисел после точки"

> **Примечание `2.3/2`**
> Данный тип состоит из двух частей
> 1. Содержимое списка в формате `BDSFT:TV`
> 2. Сигнатура конца списка (всегда `00`)

> **Примечание `2.3/3`**
> Данный тип состоит из двух частей
> 1. Содержимое словаря в формате `BDSFT:KTV`
> 2. Сигнатура конца словаря (всегда `00`)

> **Примечание `2.3/4`**
> Данный тип состоит из трёх частей
> 1. 1 байт, который обозначает тип, которого будет всё содержимое списка
> 2. Содержимое списка в формате `BDSFT:V`
> 3. Сигнатура конца списка (всегда `00`)

> **Примечание `2.3/5`**
> Данный тип состоит из трёх частей
> 1. 1 байт, который обозначает тип, которого будет всё содержимое словаря
> 2. Содержимое словаря в формате `BDSFT:KV`
> 3. Сигнатура конца словаря (всегда `00`)

> **Примечание `2.3/6`**
> Данный тип это тот же самый PNG, но
> 1. В начале не должно быть PNG сигнатуры
> 2. В блоке `IHDR` отсутствуют поля: `Метод сжатия` и `Метод фильтрации`
> 3. Отсутствуют блок `IEND`

### `2.4.` Формат записи пар ключ-значение
> У всех документов используется следуящяя запись: KTV
> 
> Формат записи: `<chars>[\[<mtype>\]]`

**Значения:**
- `chars` - Символы, указывающие на блоки данных
- `mtype` - Основной тип

**Символы (`chars`):**
- `K` - Ключ, формата TV данного пукнта, N байт
- `T` - Тип значения, 1 байт
- `V` - Само значение, N байт

**Основные типы (`mtype`):**
- `N` - `Int16`, `Int32`, `Int64`, `Int128`, `UInt8`, `UInt16`, `UInt32`, `UInt64` и `UInt128`
- `F` - `Float`, `Double` и `Decimal128`

---
- ¹ - BDSF *(**англ.** Binary Data Storage Format)* - Двоичный формат хранения данных.
- ² - `N` = Любое число; `B` = Число байт.
- ³ - Тип `NoSQL` баз данных, при котором все данные хранятся ввиде ключа и его значения.
